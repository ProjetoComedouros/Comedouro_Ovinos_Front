<template>
  <div>
    <Navbar />
    <Sidebar />

    <div class="content">
      <h3 class="mb-4">Relatório</h3>
      <ReportHeader :selecionado="selecionado" />

      <section class="dash">
        <h5 class="mb-3">Análise gráfica</h5>

        <div class="toolbar">
          <div class="seg">
            <button :class="{ active: modo === 'animal' }" @click="modo = 'animal'">Animal</button>
            <button :class="{ active: modo === 'lote' }" @click="modo = 'lote'">Lote</button>
            <button :class="{ active: modo === 'geral' }" @click="modo = 'geral'">Geral</button>
          </div>

          <div v-if="modo === 'animal'" class="input-group">
            <div class="input-item">
              <label for="animalIdInput">ID do Animal:</label>
              <input id="animalIdInput" v-model.trim="animalId" placeholder="ex: 01"
                :class="{ 'erro': mensagemErro.includes('animal') }" style="width: 100px;" />
            </div>
            <div class="input-item">
              <label for="loteIdAnimalInput">Lote:</label>
              <input id="loteIdAnimalInput" v-model.trim="loteId" placeholder="ex: A"
                :class="{ 'erro': mensagemErro.includes('lote') }" style="width: 80px;" />
            </div>
          </div>

          <div v-if="modo === 'lote'" class="input-group">
            <label>
              ID do Lote:
              <input v-model.trim="loteId" placeholder="ex: lote_real_1" @input="modo = 'lote'"
                :class="{ 'erro': mensagemErro.includes('lote') }" />
            </label>
          </div>

          <div class="seg">
            <span style="margin-right:8px;">Mostrar:</span>
            <button :class="{ active: grafSelecionado === 'todos' }" @click="grafSelecionado = 'todos'">Todos</button>
            <button :class="{ active: grafSelecionado === 'ingestivo' }" @click="grafSelecionado = 'ingestivo'">Comp.
              Ingestivo</button>
            <button :class="{ active: grafSelecionado === 'desempenho' }"
              @click="grafSelecionado = 'desempenho'">Desempenho</button>
            <button :class="{ active: grafSelecionado === 'viabilidade' }"
              @click="grafSelecionado = 'viabilidade'">Viabilidade</button>

          </div>
        </div>
        <div v-if="selecionadoPonto" class="info">
          <template v-if="selecionadoPonto">
            <p>
              <strong>Selecionado:</strong>
              ID {{ selecionadoPonto.id }}
              | Lote {{ selecionadoPonto.lote || (modo === 'lote' ? loteId : 'N/A') }}
              | {{ formatSelectedX(selecionadoPonto) }}
              | {{ selecionadoPonto.y_unit || 'Valor' }}: {{ formatSelectedY(selecionadoPonto) }}
            </p>
          </template>
        </div>
        <p v-if="mensagemErro" class="text-red-600 font-bold mt-2">
          {{ mensagemErro }}
        </p>

        <div class="grid">

          <IngestivoCharts :pontos="fonte" :graf-selecionado="grafSelecionado" :highlight-id="highlightId"
            :minutes-to-time="minutesToTime" :format-date="formatDate" :modo="modoGrafico"
            :minutesToTimeOfDay="minutesToTimeOfDay" @point-click="handlePointClick" />

          <DesempenhoCharts :pontos="fonte" :graf-selecionado="grafSelecionado" :highlight-id="highlightId"
            :format-date="formatDate" :format-kg="formatKg" :modo="modoGrafico" @point-click="handlePointClick" />

          <ViabilidadeCharts :pontos="fonte" :graf-selecionado="grafSelecionado" :highlight-id="highlightId"
            :format-date="formatDate" :format-kg="formatKg" :format-reais="formatReais" :modo="modoGrafico"
            @point-click="handlePointClick" />

        </div>
      </section>

      <HourlyDetailModal v-if="showHourlyModal" :data="hourlyData" :animal-id="animalId"
        :data-selecionada="selecionadoPonto.x" @close="showHourlyModal = false" />

    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, watch } from 'vue'
import Navbar from '@/components/ReportPage/ReportNavbar.vue'
import Sidebar from '@/components/ReportPage/ReportSidebar.vue'
import ReportHeader from '@/components/ReportPage/ReportHeader.vue'

import IngestivoCharts from '@/components/charts/IngestivoCharts.vue'
import DesempenhoCharts from '@/components/charts/DesempenhoCharts.vue'
import ViabilidadeCharts from '@/components/charts/ViabilidadeCharts.vue'

// IMPORTAÇÕES DA API
import { getConsumoDiario, getMinutoPorRefeicao } from '@/api/comportamentoIngestivo.js';
import { getEvolucaoPeso, getEvolucaoConsumoDiario, getEvolucaoGanho, getEvolucaoGMD } from '@/api/desempenho.js';
import { getCustoTotal, getEvolucaoCustoDiario, getGanhoPorDia } from '@/api/viabilidade.js';
import { animalGet } from '@/api/animais';
import { refeicaoGet } from '@/api/refeicoes.js';

import HourlyDetailModal from '@/components/charts/HourlyDetailModal.vue'

const mensagemErro = ref('')
const animais = ref([]);
const dadosAPI = ref(null);
const precoKgRacao = ref('0.50');
const precoKgPesoVivo = ref('10.00');

const selecionadoPonto = ref(null)

const showHourlyModal = ref(false);
const hourlyData = ref(null);

const handlePointClick = (p) => {
  // 1. Atualiza a barra "Selecionado:"
  selecionadoPonto.value = p;

  if (modoGrafico.value === 'lote' || modoGrafico.value === 'geral') {
    // OBJETIVO 1: Clicar no Lote -> Mudar para Modo Animal
    console.log(`Modo Lote clicado. Trocando para Animal ID: ${p.id}`);
    modo.value = 'animal';
    animalId.value = p.id;
    // O 'watch' detectará a mudança e chamará fetchData('animal', p.id)

  } else if (modoGrafico.value === 'animal') {
    // OBJETIVO 2: Clicar no Animal -> Abrir Modal por Hora

    // Verifica se o clique foi em um gráfico de Data (e não de Refeição)
    // (p.x vem do 'transformData' e é um objeto Date)
    if (p.x instanceof Date) {
      console.log(`Modo Animal clicado. Buscando dados por hora para ${p.id} em ${p.x}`);
      fetchHourlyData(p.id, p.x); // Chama a nova função
    } else {
      // Clique em gráfico de refeição (eixo X linear, ex: "Refeição #12")
      console.log("Clique em gráfico de refeição (eixo X linear).");
    }
  }
}

// ====== CONTROLES DA SEÇÃO ======
const modo = ref('lote') // Modo do BOTÃO
const modoGrafico = ref('lote') // Modo dos DADOS (Gráfico)
const animalId = ref('')
const loteId = ref('lote_real_1')
const grafSelecionado = ref('todos')

const emptySource = {
  ingestivo: [],
  desempenho: [],
  viabilidade: [],
  custo: [],
  EvolucaoPVPeriodo: [],
  EvolucaoPVDia: [],
  EvolucaoGMD: [],
  EvolucaoGanho: [],
  horaEntrada: [],
  horaSaida: [],
  minRefeicao: [],
  consumoDiario: [],
  ganhopordia: [],
  evolucaoCusto: []
};

// --- FUNÇÕES DE PROCESSAMENTO (CORRIGIDAS) ---

/**
 * Transforma dados brutos da API (formato { 'data': valor }) em um array de pontos.
 * CORRIGIDO: Agora aceita e atribui 'currentLote' (Request 3)
 */
const transformData = (data, currentId, currentTipo, currentLote = null) => {
  if (!data || typeof data !== 'object' || Object.keys(data).length === 0) {
    return [];
  }
  return Object.entries(data).map(([date, value]) => {
    const dateStringWithTime = `${date}T12:00:00Z`;
    const dateObject = new Date(dateStringWithTime);

    let pontoId, pontoLote;

    if (currentTipo === 'animal') {
      // Modo Individual
      pontoId = currentId;
      pontoLote = loteId.value; // Pega o lote do input
    } else {
      // Modo Lote ou Geral
      pontoId = currentId; // O brinco (ex: "52")
      pontoLote = currentLote; // O lote do animal (ex: 1 ou "lote_real_1")
    }

    return {
      x: dateObject,
      y: value,
      id: pontoId,
      lote: pontoLote, // ⬅️ CORRIGIDO (Request 3)
    }
  });
};

/**
 * Processa o array de refeições brutas (agora lê o ID e Lote do animal injetado).
 */
function processarRefeicoesBrutas(refeicoesBrutas, fallbackLoteId) {
  const horaEntradaData = [];
  const horaSaidaData = [];
  const ingestivoData = [];

  if (!Array.isArray(refeicoesBrutas)) return { horaEntradaData, horaSaidaData, ingestivoData };

  refeicoesBrutas.forEach((refeicao, index) => {
    const xValue = index + 1;
    const entradaMins = timeToMinutes(refeicao.horario_entrada);
    const saidaMins = timeToMinutes(refeicao.horario_saida);
    const duracaoMins = calculateDuration(refeicao.horario_entrada, refeicao.horario_saida);

    // Lê o ID e Lote do animal (injetado) ou usa o fallback
    const animalId = refeicao.animal_brinco || fallbackLoteId;
    const loteId = refeicao.animal_lote || fallbackLoteId;

    const pontoBase = { x: xValue, id: animalId, lote: loteId };

    horaEntradaData.push({ ...pontoBase, y: entradaMins });
    horaSaidaData.push({ ...pontoBase, y: saidaMins });
    ingestivoData.push({ ...pontoBase, y: duracaoMins });
  });

  return { horaEntradaData, horaSaidaData, ingestivoData };
}

/**
 * Calcula a Viabilidade (Ganho - Custo), tratando todas as datas.
 */
function calcularViabilidade(objGanho, objCusto) {
  const viabilidade = {};
  if (!objGanho || !objCusto) return {};
  const todasAsDatas = new Set([
    ...Object.keys(objGanho),
    ...Object.keys(objCusto)
  ]);
  todasAsDatas.forEach(data => {
    /* eslint-disable-next-line no-prototype-builtins */
    const ganho = objGanho[data] || 0;
    const custo = objCusto[data] || 0;
    viabilidade[data] = ganho - custo;
  });
  return viabilidade;
}

/**
 * Converte Gramas para Quilos (para dados de Consumo).
 */
function dividirValoresPor1000(objDados) {
  if (!objDados || typeof objDados !== 'object') {
    return objDados;
  }
  const objConvertido = {};
  for (const data in objDados) {
    if (Object.prototype.hasOwnProperty.call(objDados, data)) {
      const valorEmGramas = Number(objDados[data]);
      if (!isNaN(valorEmGramas)) {
        objConvertido[data] = valorEmGramas / 1000; // Converte g para kg
      }
    }
  }
  return objConvertido;
}

/**
 * Busca dados para UM animal e INJETA o ID e LOTE nas refeições.
 */
async function fetchAllDataForOneAnimal(tipo, id, lote) { // ⬅️ Aceita 'lote'
  const precoRacao = precoKgRacao.value;
  const precoPesoVivo = precoKgPesoVivo.value;

  try {
    const [consumo, minuto, refeicoesBrutas, evolucaoPeso, evolucaoConsumo, evolucaoGanho, evolucaoGMD,
      custoTotal, evolucaoCusto, ganhoPorDia] = await Promise.all([
        (async () => { try { return await getConsumoDiario(tipo, id); } catch (e) { return null; } })(),
        (async () => { try { return await getMinutoPorRefeicao(tipo, id); } catch (e) { return null; } })(),
        (async () => {
          if (tipo !== 'animal') return [];
          try {
            const refeicoes = await refeicaoGet(null, { animal: id });
            if (Array.isArray(refeicoes)) {
              // Injeta o brinco E o lote
              return refeicoes.map(r => ({ ...r, animal_brinco: id, animal_lote: lote }));
            }
            return [];
          } catch (e) {
            return [];
          }
        })(),
        (async () => { try { return await getEvolucaoPeso(tipo, id); } catch (e) { return null; } })(),
        (async () => { if (tipo !== 'animal') return null; try { return await getEvolucaoConsumoDiario(tipo, id); } catch (e) { return null; } })(),
        (async () => { try { return await getEvolucaoGanho(tipo, id); } catch (e) { return null; } })(),
        (async () => { try { return await getEvolucaoGMD(tipo, id); } catch (e) { return null; } })(),
        (async () => { try { return await getCustoTotal(tipo, id, Number(precoRacao)); } catch (e) { return null; } })(),
        (async () => { try { return await getEvolucaoCustoDiario(tipo, id, Number(precoRacao)); } catch (e) { return null; } })(),
        (async () => { try { return await getGanhoPorDia(tipo, id, Number(precoPesoVivo)); } catch (e) { return null; } })(),
      ]);

    const custoCorrigido_g_para_kg = dividirValoresPor1000(evolucaoCusto);

    const viabilidade = calcularViabilidade(ganhoPorDia, custoCorrigido_g_para_kg);

    return {
      id: id, // O brinco (ex: "52")
      lote: lote, // O lote (ex: "lote_real_1")
      consumo, minuto, refeicoesBrutas, evolucaoPeso, evolucaoConsumo, evolucaoGanho, evolucaoGMD,
      custoTotal, evolucaoCusto: custoCorrigido_g_para_kg, ganhoPorDia,
      viabilidade
    };
  } catch (error) {
    console.error(`[Busca Agregada] Falha crítica para ${tipo}/${id}:`, error);
    return null;
  }
}

/**
 * Combina os arrays de dados (Modo Lote).
 */
function mergeAllResults(arrayDeResultados) {
  const mergedData = {
    consumoTotal: 0,
    custoTotalAcumulado: 0,
    countValidAnimals: 0,
    evolucaoPeso: [],
    evolucaoConsumo: [],
    evolucaoGanho: [],
    evolucaoGMD: [],
    evolucaoCusto: [],
    ganhoPorDia: [],
    viabilidade: [],
    consumoDiario: [],
    minRefeicao: [],
    horaEntrada: [],
    horaSaida: [],
    ingestivo: [],
    refeicoesBrutas: [],
  };

  const validResults = arrayDeResultados.filter(result => result !== null);

  validResults.forEach(animalData => {
    const animalId = animalData.id;
    const animalLote = animalData.lote; // ⬅️ Pega o lote

    // Agregação de valores simples
    if (animalData.consumo && typeof animalData.consumo === 'object') {
      mergedData.consumoDiario.push(...transformData(dividirValoresPor1000(animalData.consumo), animalId, 'lote', animalLote));
    } else if (typeof animalData.consumo === 'number' && animalData.consumo !== null) {
      mergedData.consumoTotal += animalData.consumo;
    }
    if (typeof animalData.custoTotal === 'number' && animalData.custoTotal !== null) {
      mergedData.custoTotalAcumulado += animalData.custoTotal;
    }

    // Arrays de Evolução (passando o 'animalLote')
    if (animalData.evolucaoPeso) {
      mergedData.evolucaoPeso.push(...transformData(animalData.evolucaoPeso, animalId, 'lote', animalLote));
    }
    if (animalData.evolucaoConsumo) {
      mergedData.evolucaoConsumo.push(...transformData(dividirValoresPor1000(animalData.evolucaoConsumo), animalId, 'lote', animalLote));
    }
    if (animalData.evolucaoGanho) {
      mergedData.evolucaoGanho.push(...transformData(animalData.evolucaoGanho, animalId, 'lote', animalLote));
    }
    if (animalData.evolucaoGMD) {
      mergedData.evolucaoGMD.push(...transformData(animalData.evolucaoGMD, animalId, 'lote', animalLote));
    }
    if (animalData.evolucaoCusto) {
      mergedData.evolucaoCusto.push(...transformData(animalData.evolucaoCusto, animalId, 'lote', animalLote));
    }
    if (animalData.ganhoPorDia) {
      mergedData.ganhoPorDia.push(...transformData(animalData.ganhoPorDia, animalId, 'lote', animalLote));
    }
    if (animalData.viabilidade) {
      mergedData.viabilidade.push(...transformData(animalData.viabilidade, animalId, 'lote', animalLote));
    }
    if (animalData.minuto && typeof animalData.minuto === 'object') {
      mergedData.minRefeicao.push(...transformData(animalData.minuto, animalId, 'lote', animalLote));
    }
    if (Array.isArray(animalData.refeicoesBrutas)) {
      mergedData.refeicoesBrutas.push(...animalData.refeicoesBrutas);
    }
    mergedData.countValidAnimals++;
  });

  const { horaEntradaData, horaSaidaData, ingestivoData } = processarRefeicoesBrutas(
    mergedData.refeicoesBrutas,
    loteId.value
  );
  mergedData.horaEntrada = horaEntradaData;
  mergedData.horaSaida = horaSaidaData;
  mergedData.ingestivo = ingestivoData;
  delete mergedData.refeicoesBrutas;

  if (mergedData.countValidAnimals > 0) {
    mergedData.consumoMedio = mergedData.consumoTotal / mergedData.countValidAnimals;
    mergedData.custoMedio = mergedData.custoTotalAcumulado / mergedData.countValidAnimals;
  } else {
    mergedData.consumoMedio = 0;
    mergedData.custoMedio = 0;
  }

  console.log("[mergeAllResults] Dados Agregados Finais:", mergedData);
  return mergedData;
}

async function fetchHourlyData(animalId, data) {
  // Formata a data para YYYY-MM-DD
  let isoDate;
  try {
    isoDate = data.toISOString().split('T')[0];
  } catch (e) {
    console.error("Data inválida para drill-down:", data);
    return;
  }

  try {
    // 1. Chama a API (getConsumoDiario com data)
    // A API retorna {"12:00:00": 300.5, ...} (em gramas)
    const dados = await getConsumoDiario('animal', animalId, isoDate);

    hourlyData.value = dados;
    showHourlyModal.value = true; // 2. Mostra o modal

  } catch (e) {
    mensagemErro.value = `Erro ao buscar dados por hora para ${isoDate}.`;
  }
}

/**
 * Função principal de busca de dados (Modo Individual ou Lote)
 */
async function fetchData(tipo, id) {
  mensagemErro.value = '';
  dadosAPI.value = null;
  modoGrafico.value = tipo; // Atualiza o modo do gráfico (animal, lote, ou geral)
  console.log(`[fetchData] Iniciando busca. Tipo: '${tipo}', ID: '${id}'`);

  const isBuscaIndividual = (tipo === 'animal' && id);

  try {
    if (isBuscaIndividual) {
      // ############ MODO INDIVIDUAL ############
      const [consumo, minuto, refeicoesBrutas, evolucaoPeso, evolucaoConsumo, evolucaoGanho, evolucaoGMD,
        custoTotal, evolucaoCusto, ganhoPorDia] = await Promise.all([
          (async () => { try { return await getConsumoDiario(tipo, id); } catch (e) { return null; } })(),
          (async () => { try { return await getMinutoPorRefeicao(tipo, id); } catch (e) { return null; } })(),
          (async () => {
            if (tipo !== 'animal' || !id) return []; try {
              const refeicoes = await refeicaoGet(null, { animal: id });
              if (Array.isArray(refeicoes)) {
                return refeicoes.map(r => ({ ...r, animal_brinco: id, animal_lote: loteId.value }));
              }
              return [];
            } catch (e) { return []; }
          })(),
          (async () => { if (tipo !== 'animal') return null; try { return await getEvolucaoPeso(tipo, id); } catch (e) { return null; } })(),
          (async () => { if (tipo !== 'animal') return null; try { return await getEvolucaoConsumoDiario(tipo, id); } catch (e) { return null; } })(),
          (async () => { if (tipo !== 'animal') return null; try { return await getEvolucaoGanho(tipo, id); } catch (e) { return null; } })(),
          (async () => { if (tipo !== 'animal') return null; try { return await getEvolucaoGMD(tipo, id); } catch (e) { return null; } })(),
          (async () => { try { return await getCustoTotal(tipo, id, Number(precoKgRacao.value)); } catch (e) { return null; } })(),
          (async () => { try { return await getEvolucaoCustoDiario(tipo, id, Number(precoKgRacao.value)); } catch (e) { return null; } })(),
          (async () => { try { return await getGanhoPorDia(tipo, id, Number(precoKgPesoVivo.value)); } catch (e) { return null; } })(),
        ]);

      const { horaEntradaData, horaSaidaData, ingestivoData: duracaoRefeicao } = processarRefeicoesBrutas(
        refeicoesBrutas, id
      );
      const custoCorrigido_g_para_kg = dividirValoresPor1000(evolucaoCusto);
      const viabilidade = calcularViabilidade(ganhoPorDia, custoCorrigido_g_para_kg);

      const consumoCorrigido = dividirValoresPor1000(consumo);
      const evolucaoConsumoCorrigido = dividirValoresPor1000(evolucaoConsumo);

      // MAPEAMENTO (INDIVIDUAL)
      dadosAPI.value = {
        ...emptySource,
        consumoDiario: transformData(consumoCorrigido, id, tipo, loteId.value),
        minRefeicao: transformData(minuto, id, tipo),
        horaEntrada: horaEntradaData,
        horaSaida: horaSaidaData,
        ingestivo: duracaoRefeicao,
        EvolucaoPVDia: transformData(evolucaoPeso, id, tipo, loteId.value),
        EvolucaoConsumoDiario: transformData(evolucaoConsumoCorrigido, id, tipo, loteId.value),
        EvolucaoGanho: transformData(evolucaoGanho, id, tipo),
        EvolucaoGMD: transformData(evolucaoGMD, id, tipo),
        custoTotal: custoTotal?.custo_total || 0,
        evolucaoCusto: transformData(custoCorrigido_g_para_kg, id, tipo, loteId.value),
        ganhopordia: transformData(ganhoPorDia, id, tipo, loteId.value),
        viabilidade: transformData(viabilidade, id, tipo, loteId.value),
        EvolucaoPVPeriodo: transformData(evolucaoPeso, id, tipo), // <-- CORREÇÃO AQUI
      };

    } else {
      // ############ MODO LOTE/GERAL ############

      const idDoLote = id; // Será 'lote_real_1' (lote) ou 'null' (geral)
      let animaisDoLote;

      if (tipo === 'geral') { // Request 2: Modo Geral
        console.log("[fetchData] Modo GERAL: buscando TODOS os animais.");
        animaisDoLote = await animalGet(); // Sem filtro
      } else { // Request 1: Modo Lote Específico
        console.log(`[fetchData] Modo LOTE: buscando animais do lote '${idDoLote}'.`);
        animaisDoLote = await animalGet(null, { lote: idDoLote });
      }

      const animaisFiltrados = animaisDoLote.filter(
        animal => animal.brinco_numero?.toLowerCase() !== "ovelha001"
      );
      if (animaisFiltrados.length === 0) {
        mensagemErro.value = `⚠️ Nenhum animal válido encontrado para a busca.`;
        return;
      }

      // CORREÇÃO: Passa o 'animal.lote' (que pode ser o nome ou ID)
      const todasPromises = animaisFiltrados.map(animal => {
        return fetchAllDataForOneAnimal('animal', animal.brinco_numero, animal.lote);
      });
      const resultadosDeTodosAnimais = await Promise.all(todasPromises);

      const dadosAgregados = mergeAllResults(resultadosDeTodosAnimais);

      // MAPEAMENTO (LOTE)
      dadosAPI.value = {
        ...emptySource,
        consumoDiario: dadosAgregados.consumoDiario,
        minRefeicao: dadosAgregados.minRefeicao,
        horaEntrada: dadosAgregados.horaEntrada,
        horaSaida: dadosAgregados.horaSaida,
        ingestivo: dadosAgregados.ingestivo,
        EvolucaoPVDia: dadosAgregados.evolucaoPeso,
        EvolucaoConsumoDiario: dadosAgregados.evolucaoConsumo,
        EvolucaoGanho: dadosAgregados.evolucaoGanho,
        EvolucaoGMD: dadosAgregados.evolucaoGMD,
        custoTotal: dadosAgregados.custoTotalAcumulado || 0,
        evolucaoCusto: dadosAgregados.evolucaoCusto,
        ganhopordia: dadosAgregados.ganhoPorDia,
        viabilidade: dadosAgregados.viabilidade,
        EvolucaoPVPeriodo: dadosAgregados.evolucaoPeso, // <-- E CORREÇÃO AQUI
      };
    }
  } catch (error) {
    console.error("Erro no fetchData:", error);
    const serverError = error.response?.data?.erro;
    mensagemErro.value = serverError || 'Erro desconhecido ao buscar dados.';
    dadosAPI.value = null;
  }
}

onMounted(async () => {
  try {
    const listaCompleta = await animalGet();
    animais.value = listaCompleta;
    console.log("Lista Completa de Animais:", listaCompleta);
  } catch (error) {
    console.error("Erro ao carregar lista de animais:", error);
  }
});
onMounted(() => {
  // Carga inicial (Modo Lote padrão)
  fetchData('lote', loteId.value || 'lote_real_1');
});

// --- Funções Auxiliares de Formatação ---

// 1. DURAÇÃO (MM:SS)
const minutesToTime = (totalMins) => {
  const mins = Number(totalMins);
  if (isNaN(mins) || mins < 0) return '00:00';

  // Calcula minutos TOTAIS (parte inteira)
  const minutesPart = Math.floor(mins);
  // Calcula a parte decimal (os segundos)
  const decimalPart = mins - minutesPart;
  // Converte a parte decimal para segundos
  const seconds = Math.round(decimalPart * 60);

  // Formata as partes (SEM a lógica 'if/else' que causava o bug)
  const m = String(minutesPart).padStart(2, '0');
  const s = String(seconds).padStart(2, '0');

  return `${m}:${s}`; // Sempre retorna MM:SS (ex: "57:44" ou "60:00")
}

// 2. HORA DO DIA (HH:MM)
const minutesToTimeOfDay = (totalMins) => {
  const mins = Number(totalMins);
  if (isNaN(mins) || mins < 0 || mins > 1440) {
    if (mins > 1440) return ' - ';
    return '00:00';
  }

  const hours = Math.floor(mins / 60);
  const minutes = Math.floor(mins % 60);

  const h = String(hours).padStart(2, '0');
  const m = String(minutes).padStart(2, '0');

  return `${h}:${m}`;
};

const formatDate = (date) => {
  if (!date) return '';
  let d = date instanceof Date ? date : new Date(date);
  if (!isNaN(d.getTime())) {
    return d.toLocaleDateString('pt-BR', { timeZone: 'UTC' });
  }
  return String(date);
}
const formatKg = (value) => {
  const numValue = Number(value);
  if (isNaN(numValue)) return 'N/A kg';
  return `${numValue.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 3 })} kg`;
}

const formatReais = (value) => {
  const num = Number(value);
  if (isNaN(num)) {
    return 'R$ 0,00';
  }
  // Formata o número absoluto e posiciona o sinal de negativo após o "R$"
  const valorFormatado = Math.abs(num).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

  return num < 0 ? `R$ -${valorFormatado}` : `R$ ${valorFormatado}`;
}

const timeToMinutes = (timeString) => {
  if (!timeString) return 0;
  const [h, m, s] = timeString.split(':').map(Number);
  return h * 60 + m + (s / 60 || 0);
};

const calculateDuration = (entrada, saida) => {
  return timeToMinutes(saida) - timeToMinutes(entrada);
};

// 4. FUNÇÃO formatSelectedX CORRIGIDA
const formatSelectedX = (ponto) => {
  if (!ponto || ponto.x === undefined) return 'N/A';

  const yUnit = ponto.y_unit || '';

  // Verifica se é um gráfico de Ingestivo (onde X é um número de refeição)
  if (yUnit.includes('Hora') || yUnit.includes('Duração') || yUnit.includes('Min/Refeição')) {
    return `Presença no comedouro ${ponto.x}`;
  }

  // Senão, é um gráfico de Data
  return `Data/Ref: ${formatDate(ponto.x)}`;
};

const formatSelectedY = (ponto) => {
  const yUnit = ponto.y_unit || 'Valor';
  if (!ponto || ponto.y === undefined) return 'N/A';
  switch (yUnit) {
    case 'Minutos':
    case 'Duração (min)':
    case 'Min/Refeição (Duração)':
      return minutesToTime(ponto.y); // Formato Duração (MM:SS)
    case 'Horas':
    case 'Hora (HH:MM)':
    case 'Hora Entrada':
    case 'Hora Saída':
      return minutesToTimeOfDay(ponto.y); // Formato Hora do Dia (HH:MM)
    case 'Kg':
    case 'GMD (kg)':
    case 'Peso Vivo (kg)':
    case 'Consumo (kg)':
      return formatKg(ponto.y);
    case 'Reais (R$)':
    case 'Custo/Dia (R$)':
    case 'Ganho/Dia (R$)':
    case 'Viabilidade/Dia (R$)':
      return formatReais(ponto.y);
    default:
      return ponto.y;
  }
};

const selecionado = ref(false)

let debounceTimer;

// Lógica de Watch (Observador) - CORRIGIDA
watch([modo, animalId, loteId], ([newModo, newAnimalId, newLoteId]) => {
  selecionadoPonto.value = null;
  mensagemErro.value = '';

  clearTimeout(debounceTimer);

  debounceTimer = setTimeout(() => {
    if (newModo === 'geral') {
      animalId.value = '';
      loteId.value = ''; // Limpa o loteId se for 'Geral'
    }

    const ID_LOTE_PADRAO = loteId.value || 'lote_real_1';

    if (newModo === 'animal' && newAnimalId) {
      // 1. MODO ANIMAL
      fetchData('animal', newAnimalId);
    }
    else if (newModo === 'lote' && newLoteId) {
      // 2. MODO LOTE (Request 1)
      fetchData('lote', newLoteId);
    }
    else if (newModo === 'geral') {
      // 3. MODO GERAL (Request 2)
      fetchData('geral', null); // 'null' ID
    }
    else {
      // 4. FALLBACK (Modo Lote/Animal vazio)
      fetchData('lote', ID_LOTE_PADRAO);
    }
  }, 500);
});

// Fonte computada
const fonte = computed(() => {
  if (!dadosAPI.value) {
    return emptySource;
  }
  return dadosAPI.value;
});

// HighlightId
const highlightId = computed(() => {
  if (selecionadoPonto.value) {
    return selecionadoPonto.value.id;
  }
  if (modo.value === 'animal' && animalId.value) {
    return animalId.value;
  }
  return null;
});

</script>

<style scoped>
:root {
  --verde-nata: #198754;
  --fundo-claro: #f8f9fa;
  --texto-cinza: #444;
}

body {
  font-family: 'Segoe UI', sans-serif;
}

.content {
  margin-left: 220px;
  padding: 2rem;
  margin-top: 56px;
}

/* seção nova */
.dash {
  background: #fff;
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  padding: 14px 16px
}

.toolbar {
  display: flex;
  gap: 16px;
  align-items: center;
  margin-bottom: 12px;
  background: #fafafa;
  border: 1px solid #eee;
  border-radius: 10px;
  padding: 10px 12px
}

.seg {
  display: flex;
  gap: 8px;
  align-items: center;
  background: #f3f4f6;
  padding: 6px;
  border-radius: 10px
}

.seg button {
  border: none;
  background: transparent;
  padding: 8px 12px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600
}

.seg button.active {
  background: #111;
  color: #fff
}

input {
  padding: 8px 10px;
  border: 1px solid #ddd;
  border-radius: 8px;
}

.input-group {
  display: flex;
  gap: 16px;
  align-items: center;
}

.input-item {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 4px;
}

.input-item label {
  font-size: 0.9rem;
  color: #555;
}

input.erro {
  border-color: #ef4444;
  background-color: #fee2e2;
}


.grid {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 16px
}

@media (max-width:1200px) {
  .grid {
    grid-template-columns: 1fr
  }
}

.info {
  margin: 8px 0 14px;
  padding: 8px 12px;
  border-left: 4px solid #2563eb;
  background: #eef2ff;
  border-radius: 8px
}

/* tabela (seu estilo original) */
.table-placeholder {
  background-color: #ffffff;
  border: 1px solid #dee2e6;
  padding: 1rem;
  border-radius: 8px;
  margin-top: 1rem;
}
</style>